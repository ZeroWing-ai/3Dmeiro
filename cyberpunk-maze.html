<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>サイバー迷宮 - Cyberpunk Maze</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            color: #00ffff;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            background: radial-gradient(circle, #001133 0%, #000000 100%);
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 64, 170, 0.2);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        .ui-panel h3 {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .ui-panel p {
            color: #ffffff;
            font-size: 12px;
            margin: 5px 0;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        #topLeftPanel {
            top: 20px;
            left: 20px;
            width: 250px;
        }
        
        #topRightPanel {
            top: 20px;
            right: 20px;
            width: 280px;
        }
        
        #miniMapPanel {
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
        }
        
        #miniMap {
            width: 170px;
            height: 170px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            margin-top: 10px;
            position: relative;
        }
        
        .weapon-item {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0080ff;
            border-radius: 5px;
            padding: 5px;
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .weapon-name {
            color: #00bfff;
        }
        
        .weapon-count {
            color: #ffffff;
            font-weight: bold;
        }
        
        .glow-effect {
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff; }
            to { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff; }
        }
        
        .status-bar {
            background: linear-gradient(90deg, #0080ff, #00bfff);
            height: 4px;
            border-radius: 2px;
            margin: 5px 0;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 64, 170, 0.2);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px;
            font-size: 11px;
            color: #00ffff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Top Left Panel - Stage Info -->
        <div id="topLeftPanel" class="ui-panel">
            <h3 class="glow-effect">ステージ情報</h3>
            <p><span style="color: #00ffff;">ステージ1:</span> デジタル迷宮</p>
            <p><span style="color: #00ffff;">スコア:</span> <span id="score">0</span></p>
            <p><span style="color: #00ffff;">残りデータ:</span> <span id="collectibles">3/3</span></p>
            <div class="status-bar" style="width: 100%;"></div>
        </div>
        
        <!-- Top Right Panel - Weapons/Tools -->
        <div id="topRightPanel" class="ui-panel">
            <h3 class="glow-effect">装備システム</h3>
            <div id="weaponsList">
                <div class="weapon-item">
                    <span class="weapon-name">武器: ネオンスキャナー</span>
                    <span class="weapon-count">[<span id="neon-scanner">2</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">ツール: クァンタムコンパス</span>
                    <span class="weapon-count">[<span id="quantum-compass">1</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">デバイス: ホログラムマッパー</span>
                    <span class="weapon-count">[<span id="hologram-mapper">3</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">装備: サイバーブースター</span>
                    <span class="weapon-count">[<span id="cyber-booster">1</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">武器: デジタルソード</span>
                    <span class="weapon-count">[<span id="digital-sword">2</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">防御: フォトンシールド</span>
                    <span class="weapon-count">[<span id="photon-shield">1</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">キー: バイナリーキー</span>
                    <span class="weapon-count">[<span id="binary-key">1</span>]</span>
                </div>
                <div class="weapon-item">
                    <span class="weapon-name">ツール: エナジードリル</span>
                    <span class="weapon-count">[<span id="energy-drill">1</span>]</span>
                </div>
            </div>
        </div>
        
        <!-- Mini Map Panel -->
        <div id="miniMapPanel" class="ui-panel">
            <h3 class="glow-effect">ナビゲーション</h3>
            <div id="miniMap"></div>
        </div>
        
        <!-- Instructions -->
        <div id="instructions">
            <p>WASD: 移動 | マウス: 視点 | クリック: マウスロック | 1-8: ツール使用</p>
        </div>
    </div>

    <script>
        // Game Variables
        let scene, camera, renderer, maze, player;
        let mazeData = [];
        let gameState = {
            score: 0,
            collectibles: 3,
            totalCollectibles: 3,
            isGameOver: false,
            tools: {
                'neon-scanner': 2,
                'quantum-compass': 1,
                'hologram-mapper': 3,
                'cyber-booster': 1,
                'digital-sword': 2,
                'photon-shield': 1,
                'binary-key': 1,
                'energy-drill': 1
            },
            playerPosition: { x: -9, z: -9 },
            goalPosition: { x: 9, z: 9 },
            mazeSize: 21
        };
        
        let keys = {};
        let particles = [];
        
        // First-person camera controls
        let isMouseLocked = false;
        let yaw = 0;
        let pitch = 0;
        const mouseSpeed = 0.002;
        
        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);
            
            // Create first-person camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-9, 1.6, -9);
            camera.rotation.order = 'YXZ';
            
            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lighting
            setupLighting();
            
            // Generate maze
            generateMaze();
            
            // Create player
            createPlayer();
            
            // Add event listeners
            addEventListeners();
            
            // Start game loop
            animate();
            
            // Setup mini-map
            setupMiniMap();
        }
        
        
        function setupLighting() {
            // Ambient light for basic visibility
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Point lights for atmosphere
            const pointLight1 = new THREE.PointLight(0x00ffff, 1.5, 50);
            pointLight1.position.set(0, 3, 0);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0080ff, 1, 40);
            pointLight2.position.set(-8, 3, -8);
            scene.add(pointLight2);
        }
        
        function generateMaze() {
            mazeData = createMazeData(gameState.mazeSize);
            
            // Create maze walls - solid wireframe style
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                wireframe: false,
                transparent: true,
                opacity: 0.7
            });
            
            const wireframeMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff,
                linewidth: 4
            });
            
            const offset = -gameState.mazeSize / 2;
            
            for (let x = 0; x < gameState.mazeSize; x++) {
                for (let z = 0; z < gameState.mazeSize; z++) {
                    if (mazeData[x][z] === 1) {
                        // Create taller wall cube for first-person view
                        const wallGeometry = new THREE.BoxGeometry(1, 4, 1);
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x + offset, 2, z + offset);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        
                        // Add wireframe edges
                        const edges = new THREE.EdgesGeometry(wallGeometry);
                        const wireframe = new THREE.LineSegments(edges, wireframeMaterial);
                        wireframe.position.set(x + offset, 2, z + offset);
                        scene.add(wireframe);
                    }
                }
            }
            
            // Create floor with grid pattern
            createCyberpunkFloor();
            
            // Add collectibles
            addCollectibles(mazeData);
            
            
            // Add goal
            addGoal();
            
        }
        
        function createMazeData(size) {
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // Simple maze generation - create paths
            function carvePath(x, z) {
                maze[x][z] = 0;
                
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                directions.sort(() => Math.random() - 0.5);
                
                for (const [dx, dz] of directions) {
                    const nx = x + dx;
                    const nz = z + dz;
                    
                    if (nx > 0 && nx < size - 1 && nz > 0 && nz < size - 1 && maze[nx][nz] === 1) {
                        maze[x + dx/2][z + dz/2] = 0;
                        carvePath(nx, nz);
                    }
                }
            }
            
            carvePath(1, 1);
            
            // Ensure goal is reachable
            maze[19][19] = 0;
            
            return maze;
        }
        
        function createCyberpunkFloor() {
            // Main floor
            const floorGeometry = new THREE.PlaneGeometry(gameState.mazeSize, gameState.mazeSize);
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0x001122,
                emissive: 0x000811
            });
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0, 0);
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Grid lines
            const gridHelper = new THREE.GridHelper(gameState.mazeSize, gameState.mazeSize, 0x0080ff, 0x004080);
            gridHelper.position.set(0, 0.01, 0);
            scene.add(gridHelper);
        }
        
        function createPlayer() {
            const playerGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
            const playerMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x004080
            });
            
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(gameState.playerPosition.x, 0.25, gameState.playerPosition.z);
            player.castShadow = true;
            scene.add(player);
            
            // Add glow effect around player
            const glowGeometry = new THREE.RingGeometry(0.5, 0.7, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.rotation.x = -Math.PI / 2;
            glow.position.set(gameState.playerPosition.x, 0.01, gameState.playerPosition.z);
            scene.add(glow);
            
            player.glow = glow;
        }
        
        function addCollectibles(mazeData) {
            const collectiblePositions = [];
            
            // Find valid positions for collectibles
            for (let x = 1; x < gameState.mazeSize - 1; x++) {
                for (let z = 1; z < gameState.mazeSize - 1; z++) {
                    if (mazeData[x][z] === 0 && 
                        (x !== gameState.playerPosition.x || z !== gameState.playerPosition.z) &&
                        (x !== gameState.goalPosition.x || z !== gameState.goalPosition.z)) {
                        collectiblePositions.push({x, z});
                    }
                }
            }
            
            // Place collectibles
            for (let i = 0; i < gameState.totalCollectibles && i < collectiblePositions.length; i++) {
                const pos = collectiblePositions[Math.floor(Math.random() * collectiblePositions.length)];
                collectiblePositions.splice(collectiblePositions.indexOf(pos), 1);
                
                const collectibleGeometry = new THREE.OctahedronGeometry(0.2);
                const collectibleMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x002040,
                    transparent: true,
                    opacity: 0.9
                });
                
                const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                collectible.position.set(pos.x, 0.5, pos.z);
                collectible.userData = { type: 'collectible' };
                scene.add(collectible);
                
                // Add rotation animation
                collectible.rotation.x = Math.random() * Math.PI;
                collectible.rotation.y = Math.random() * Math.PI;
            }
        }
        
        
        
        function addGoal() {
            // Create goal beacon
            const goalGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
            const goalMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            
            const goal = new THREE.Mesh(goalGeometry, goalMaterial);
            goal.position.set(gameState.goalPosition.x, 1, gameState.goalPosition.z);
            goal.userData = { type: 'goal' };
            scene.add(goal);
            
            // Add goal glow ring
            const ringGeometry = new THREE.RingGeometry(0.5, 0.8, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(gameState.goalPosition.x, 0.01, gameState.goalPosition.z);
            scene.add(ring);
            
            goal.ring = ring;
        }
        
        function addEventListeners() {
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                
                // Tool usage
                switch(event.code) {
                    case 'Digit1':
                        useTool('neon-scanner');
                        break;
                    case 'Digit2':
                        useTool('quantum-compass');
                        break;
                    case 'Digit3':
                        useTool('hologram-mapper');
                        break;
                    case 'Digit4':
                        useTool('cyber-booster');
                        break;
                    case 'Digit5':
                        useTool('digital-sword');
                        break;
                    case 'Digit6':
                        useTool('photon-shield');
                        break;
                    case 'Digit7':
                        useTool('binary-key');
                        break;
                    case 'Digit8':
                        useTool('energy-drill');
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
            
            // Mouse lock for first-person view
            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('click', () => {
                if (!isMouseLocked) {
                    canvas.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isMouseLocked = document.pointerLockElement === canvas;
            });
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseLocked) {
                    yaw -= event.movementX * mouseSpeed;
                    pitch -= event.movementY * mouseSpeed;
                    
                    // Limit pitch to prevent camera flipping
                    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                    
                    // Update camera rotation
                    camera.rotation.set(pitch, yaw, 0);
                }
            });
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function useTool(toolName) {
            if (gameState.tools[toolName] > 0) {
                gameState.tools[toolName]--;
                document.getElementById(toolName).textContent = gameState.tools[toolName];
                
                // Tool effects
                switch(toolName) {
                    case 'neon-scanner':
                        createScannerEffect();
                        break;
                    case 'quantum-compass':
                        createCompassEffect();
                        break;
                    case 'hologram-mapper':
                        createMapperEffect();
                        break;
                    case 'cyber-booster':
                        createBoosterEffect();
                        break;
                    case 'digital-sword':
                        createSwordEffect();
                        break;
                    case 'photon-shield':
                        createShieldEffect();
                        break;
                    case 'binary-key':
                        createKeyEffect();
                        break;
                    case 'energy-drill':
                        createDrillEffect();
                        break;
                }
                
                // Add score
                gameState.score += 50;
                updateUI();
            }
        }
        
        function createScannerEffect() {
            // Create scanning wave effect
            const waveGeometry = new THREE.RingGeometry(0.1, 5, 32);
            const waveMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5
            });
            
            const wave = new THREE.Mesh(waveGeometry, waveMaterial);
            wave.position.copy(player.position);
            wave.rotation.x = -Math.PI / 2;
            scene.add(wave);
            
            // Animate wave expansion
            let scale = 0;
            const animateWave = () => {
                scale += 0.1;
                wave.scale.set(scale, scale, 1);
                waveMaterial.opacity = Math.max(0, 0.5 - scale * 0.1);
                
                if (scale < 5) {
                    requestAnimationFrame(animateWave);
                } else {
                    scene.remove(wave);
                }
            };
            animateWave();
        }
        
        function createCompassEffect() {
            // Show direction to goal
            const direction = new THREE.Vector3(
                gameState.goalPosition.x - gameState.playerPosition.x,
                0,
                gameState.goalPosition.z - gameState.playerPosition.z
            ).normalize();
            
            const arrowGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            
            arrow.position.copy(player.position);
            arrow.position.y += 1;
            arrow.lookAt(
                player.position.x + direction.x,
                player.position.y + 1,
                player.position.z + direction.z
            );
            arrow.rotateX(Math.PI / 2);
            
            scene.add(arrow);
            
            // Remove after 3 seconds
            setTimeout(() => {
                scene.remove(arrow);
            }, 3000);
        }
        
        function createMapperEffect() {
            // Temporarily show more of the mini-map
            updateMiniMap(true);
            setTimeout(() => updateMiniMap(false), 5000);
        }
        
        function createBoosterEffect() {
            // Increase movement speed temporarily
            player.material.emissive.setHex(0x00ffff);
            gameState.boosterActive = true;
            setTimeout(() => {
                player.material.emissive.setHex(0x004080);
                gameState.boosterActive = false;
            }, 5000);
        }
        
        function createSwordEffect() {
            // Create sword slash effect and break walls
            const swordGeometry = new THREE.PlaneGeometry(2, 0.1);
            const swordMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            
            const sword = new THREE.Mesh(swordGeometry, swordMaterial);
            sword.position.copy(player.position);
            sword.position.y += 0.5;
            
            // Get player facing direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            sword.lookAt(player.position.x + direction.x, sword.position.y, player.position.z + direction.z);
            
            scene.add(sword);
            
            // Check for breakable walls in front of player
            const frontX = Math.round(player.position.x + direction.x);
            const frontZ = Math.round(player.position.z + direction.z);
            
            // Find and remove wall at that position
            scene.children.forEach((object) => {
                if (object.type === 'Mesh' && object.geometry.type === 'BoxGeometry') {
                    if (Math.round(object.position.x) === frontX && Math.round(object.position.z) === frontZ) {
                        scene.remove(object);
                        createWallBreakEffect(object.position);
                    }
                }
            });
            
            // Animate sword
            let rotation = 0;
            const animateSword = () => {
                rotation += 0.2;
                sword.rotateZ(0.2);
                swordMaterial.opacity -= 0.05;
                
                if (swordMaterial.opacity > 0) {
                    requestAnimationFrame(animateSword);
                } else {
                    scene.remove(sword);
                }
            };
            animateSword();
        }
        
        function createWallBreakEffect(position) {
            // Create debris particles
            for (let i = 0; i < 30; i++) {
                const debrisGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
                const debrisMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0080ff,
                    transparent: true,
                    opacity: 1
                });
                
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.copy(position);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                
                debris.userData = { velocity, life: 2.0 };
                particles.push(debris);
                scene.add(debris);
            }
        }
        
        function createShieldEffect() {
            // Create protective shield around player
            const shieldGeometry = new THREE.SphereGeometry(1, 16, 8);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2,
                wireframe: true
            });
            
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.copy(player.position);
            scene.add(shield);
            
            gameState.shieldActive = true;
            
            // Animate shield
            let time = 0;
            const animateShield = () => {
                time += 0.1;
                shield.rotation.y += 0.02;
                shield.material.opacity = 0.2 + Math.sin(time) * 0.1;
                
                if (time < 50) {
                    requestAnimationFrame(animateShield);
                } else {
                    scene.remove(shield);
                    gameState.shieldActive = false;
                }
            };
            animateShield();
        }
        
        function createKeyEffect() {
            // Create key visualization and unlock special areas
            const keyGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const keyMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0x444400
            });
            
            const key = new THREE.Mesh(keyGeometry, keyMaterial);
            key.position.copy(player.position);
            key.position.y += 1;
            scene.add(key);
            
            // Spin and fade the key
            let spin = 0;
            const animateKey = () => {
                spin += 0.1;
                key.rotation.y += 0.1;
                key.position.y += 0.02;
                keyMaterial.opacity = Math.max(0, 1 - spin * 0.02);
                
                if (spin < 50) {
                    requestAnimationFrame(animateKey);
                } else {
                    scene.remove(key);
                }
            };
            animateKey();
            
            // Unlock special doors (for future expansion)
            gameState.hasKey = true;
        }
        
        function createDrillEffect() {
            // Create drilling effect and make shortcuts
            const drillGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
            const drillMaterial = new THREE.MeshBasicMaterial({
                color: 0xff8800,
                emissive: 0x442200
            });
            
            const drill = new THREE.Mesh(drillGeometry, drillMaterial);
            drill.position.copy(player.position);
            drill.position.y += 0.5;
            
            // Get direction player is facing
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            drill.lookAt(player.position.x + direction.x, drill.position.y, player.position.z + direction.z);
            
            scene.add(drill);
            
            // Create sparks effect
            for (let i = 0; i < 50; i++) {
                const sparkGeometry = new THREE.SphereGeometry(0.01);
                const sparkMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.copy(drill.position);
                
                const sparkVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                spark.userData = { velocity: sparkVelocity, life: 1.0 };
                particles.push(spark);
                scene.add(spark);
            }
            
            // Remove drill after animation
            setTimeout(() => {
                scene.remove(drill);
            }, 2000);
            
            // Create shortcut path (remove walls in a line)
            for (let i = 1; i <= 3; i++) {
                const targetX = Math.round(player.position.x + direction.x * i);
                const targetZ = Math.round(player.position.z + direction.z * i);
                
                scene.children.forEach((object) => {
                    if (object.type === 'Mesh' && object.geometry.type === 'BoxGeometry') {
                        if (Math.round(object.position.x) === targetX && Math.round(object.position.z) === targetZ) {
                            scene.remove(object);
                        }
                    }
                });
            }
        }
        
        function isValidPosition(x, z) {
            const offset = gameState.mazeSize / 2;
            
            // Convert world position to grid position
            const gridX = Math.floor(x + offset);
            const gridZ = Math.floor(z + offset);
            
            // Check boundaries
            if (gridX < 0 || gridX >= gameState.mazeSize || 
                gridZ < 0 || gridZ >= gameState.mazeSize) {
                return false;
            }
            
            // Check the exact grid position the player is in
            if (mazeData[gridX] && mazeData[gridX][gridZ] === 1) {
                return false; // Can't move into a wall
            }
            
            // Also check neighboring cells to prevent wall clipping
            const playerRadius = 0.3;
            const worldGridX = x + offset;
            const worldGridZ = z + offset;
            
            // Check if player overlaps with any nearby walls
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const checkX = gridX + dx;
                    const checkZ = gridZ + dz;
                    
                    if (checkX >= 0 && checkX < gameState.mazeSize && 
                        checkZ >= 0 && checkZ < gameState.mazeSize) {
                        
                        if (mazeData[checkX] && mazeData[checkX][checkZ] === 1) {
                            // Check if player is too close to this wall
                            const wallCenterX = checkX + 0.5;
                            const wallCenterZ = checkZ + 0.5;
                            
                            const distanceX = Math.abs(worldGridX - wallCenterX);
                            const distanceZ = Math.abs(worldGridZ - wallCenterZ);
                            
                            if (distanceX < 0.5 + playerRadius && distanceZ < 0.5 + playerRadius) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }
        
        
        function gameOver() {
            gameState.isGameOver = true;
            
            // Create dramatic game over effect
            const overlay = document.createElement('div');
            overlay.id = 'gameOverOverlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            overlay.style.zIndex = '1000';
            overlay.style.fontFamily = 'Orbitron, monospace';
            overlay.style.color = '#ffffff';
            overlay.style.textAlign = 'center';
            
            overlay.innerHTML = `
                <h1 style="font-size: 4rem; margin-bottom: 2rem; text-shadow: 0 0 20px #ff0000; animation: pulse 1s infinite;">GAME OVER</h1>
                <h2 style="font-size: 2rem; margin-bottom: 1rem; color: #ffcccc;">敵に捕まってしまいました！</h2>
                <p style="font-size: 1.2rem; margin-bottom: 2rem;">スコア: ${gameState.score}</p>
                <button id="restartBtn" style="
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    font-family: 'Orbitron', monospace;
                    background: linear-gradient(45deg, #ff0000, #ff6600);
                    color: white;
                    border: none;
                    border-radius: 10px;
                    cursor: pointer;
                    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
                    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
                ">再スタート</button>
            `;
            
            // Add pulse animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(overlay);
            
            // Restart functionality
            document.getElementById('restartBtn').addEventListener('click', () => {
                document.body.removeChild(overlay);
                document.head.removeChild(style);
                restartGame();
            });
            
            // Create dramatic screen shake effect
            let shakeCount = 0;
            const shake = () => {
                if (shakeCount < 20) {
                    camera.position.x += (Math.random() - 0.5) * 0.1;
                    camera.position.z += (Math.random() - 0.5) * 0.1;
                    shakeCount++;
                    setTimeout(shake, 50);
                }
            };
            shake();
        }
        
        function restartGame() {
            // Reset game state
            gameState.isGameOver = false;
            gameState.score = 0;
            gameState.collectibles = 3;
            gameState.playerPosition = { x: -9, z: -9 };
            
            
            // Remove all collectibles
            const objectsToRemove = [];
            scene.children.forEach(object => {
                if (object.userData && object.userData.type === 'collectible') {
                    objectsToRemove.push(object);
                }
            });
            objectsToRemove.forEach(object => scene.remove(object));
            
            // Reset player position
            player.position.set(-9, 0.25, -9);
            player.glow.position.set(-9, 0.01, -9);
            camera.position.set(-9, 1.6, -9);
            
            // Reset camera rotation
            yaw = 0;
            pitch = 0;
            camera.rotation.set(0, 0, 0);
            
            // Regenerate maze elements
            addCollectibles(mazeData);
            
            // Update UI
            updateUI();
        }
        
        function handleMovement() {
            const moveSpeed = gameState.boosterActive ? 0.2 : 0.1;
            let newX = gameState.playerPosition.x;
            let newZ = gameState.playerPosition.z;
            
            // Get forward and right vectors from camera rotation
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            right.normalize();
            
            // First-person movement based on camera direction
            if (keys['KeyW'] || keys['ArrowUp']) {
                const testX = newX + forward.x * moveSpeed;
                const testZ = newZ + forward.z * moveSpeed;
                if (isValidPosition(testX, newZ)) newX = testX;
                if (isValidPosition(newX, testZ)) newZ = testZ;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                const testX = newX - forward.x * moveSpeed;
                const testZ = newZ - forward.z * moveSpeed;
                if (isValidPosition(testX, newZ)) newX = testX;
                if (isValidPosition(newX, testZ)) newZ = testZ;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                const testX = newX - right.x * moveSpeed;
                const testZ = newZ - right.z * moveSpeed;
                if (isValidPosition(testX, newZ)) newX = testX;
                if (isValidPosition(newX, testZ)) newZ = testZ;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                const testX = newX + right.x * moveSpeed;
                const testZ = newZ + right.z * moveSpeed;
                if (isValidPosition(testX, newZ)) newX = testX;
                if (isValidPosition(newX, testZ)) newZ = testZ;
            }
            
            // Update player position
            gameState.playerPosition.x = newX;
            gameState.playerPosition.z = newZ;
            
            // Update camera position (eye level)
            camera.position.x = newX;
            camera.position.y = 1.6;
            camera.position.z = newZ;
            
            // Update player object position (for mini-map and interactions)
            player.position.x = newX;
            player.position.z = newZ;
            player.glow.position.x = newX;
            player.glow.position.z = newZ;
            
            // Check for collectibles
            checkCollectibles();
            
            // Check for goal
            checkGoal();
            
            // Update mini-map
            updateMiniMap();
        }
        
        function checkCollectibles() {
            scene.children.forEach((object) => {
                if (object.userData && object.userData.type === 'collectible') {
                    const distance = player.position.distanceTo(object.position);
                    if (distance < 0.5) {
                        scene.remove(object);
                        gameState.collectibles--;
                        gameState.score += 100;
                        updateUI();
                        
                        // Create collection effect
                        createCollectionEffect(object.position);
                    }
                }
            });
        }
        
        function checkGoal() {
            const goalDistance = Math.sqrt(
                Math.pow(gameState.playerPosition.x - gameState.goalPosition.x, 2) +
                Math.pow(gameState.playerPosition.z - gameState.goalPosition.z, 2)
            );
            
            if (goalDistance < 0.8) {
                // Player reached the goal
                gameState.score += 1000;
                updateUI();
                
                // Create victory effect
                createVictoryEffect();
                
                // Show victory message
                setTimeout(() => {
                    alert('ミッション完了！\nスコア: ' + gameState.score);
                }, 500);
            }
        }
        
        function createVictoryEffect() {
            // Create massive particle explosion
            for (let i = 0; i < 100; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0x00ffff : 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    gameState.goalPosition.x,
                    1,
                    gameState.goalPosition.z
                );
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                particle.userData = { velocity, life: 3.0 };
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function createCollectionEffect(position) {
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.02);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                
                particle.userData = { velocity, life: 1.0 };
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.userData.life -= 0.02;
                particle.userData.velocity.y -= 0.005;
                
                particle.position.add(particle.userData.velocity);
                particle.material.opacity = particle.userData.life;
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
        }
        
        function setupMiniMap() {
            updateMiniMap();
        }
        
        function updateMiniMap(enhanced = false) {
            const miniMap = document.getElementById('miniMap');
            miniMap.innerHTML = '';
            
            const scale = 170 / gameState.mazeSize;
            
            // Player dot
            const playerDot = document.createElement('div');
            playerDot.style.position = 'absolute';
            playerDot.style.width = '6px';
            playerDot.style.height = '6px';
            playerDot.style.backgroundColor = '#00ffff';
            playerDot.style.borderRadius = '50%';
            playerDot.style.left = ((gameState.playerPosition.x + gameState.mazeSize/2) * scale - 3) + 'px';
            playerDot.style.top = ((gameState.playerPosition.z + gameState.mazeSize/2) * scale - 3) + 'px';
            playerDot.style.boxShadow = '0 0 10px #00ffff';
            miniMap.appendChild(playerDot);
            
            
            // Goal dot
            const goalDot = document.createElement('div');
            goalDot.style.position = 'absolute';
            goalDot.style.width = '8px';
            goalDot.style.height = '8px';
            goalDot.style.backgroundColor = '#ffffff';
            goalDot.style.borderRadius = '50%';
            goalDot.style.left = ((gameState.goalPosition.x + gameState.mazeSize/2) * scale - 4) + 'px';
            goalDot.style.top = ((gameState.goalPosition.z + gameState.mazeSize/2) * scale - 4) + 'px';
            goalDot.style.border = '1px solid #00ffff';
            miniMap.appendChild(goalDot);
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('collectibles').textContent = 
                `${gameState.collectibles}/${gameState.totalCollectibles}`;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            handleMovement();
            updateParticles();
            
            // Animate objects
            scene.children.forEach((object) => {
                if (object.userData && object.userData.type === 'collectible') {
                    object.rotation.x += 0.01;
                    object.rotation.y += 0.02;
                    object.position.y = 0.5 + Math.sin(Date.now() * 0.005) * 0.1;
                }
                if (object.userData && object.userData.type === 'goal') {
                    object.rotation.y += 0.005;
                    object.material.emissive.setHex(Math.sin(Date.now() * 0.01) > 0 ? 0x444444 : 0x666666);
                    if (object.ring) {
                        object.ring.rotation.z += 0.01;
                    }
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>